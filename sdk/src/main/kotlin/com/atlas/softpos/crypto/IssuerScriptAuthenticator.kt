package com.atlas.softpos.crypto

import timber.log.Timber

/**
 * Issuer Script Authentication per EMV Book 2
 *
 * Validates issuer scripts (Tag 71/72) using issuer authentication data (Tag 91)
 * before allowing script execution. This prevents unauthorized script injection.
 *
 * Reference: EMV Book 2 v4.3, Section 8.2 - Issuer Authentication
 */
object IssuerScriptAuthenticator {

    /**
     * Authenticate issuer using Tag 91 data
     * EMV Book 2 Section 8.2.1
     *
     * Tag 91 format (10 bytes typically):
     * - ARPC (8 bytes): Authorization Response Cryptogram
     * - ARC (2 bytes): Authorization Response Code (optional, may be separate)
     *
     * @param arqc 8-byte ARQC generated by card
     * @param issuerAuthData Tag 91 data from online response
     * @param arc 2-byte Authorization Response Code (Tag 8A)
     * @param sessionKey Session key for MAC verification
     * @param arpcMethod ARPC verification method (1 or 2)
     * @return Authentication result with details
     */
    fun authenticateIssuer(
        arqc: ByteArray,
        issuerAuthData: ByteArray,
        arc: ByteArray,
        sessionKey: ByteArray,
        arpcMethod: ArpcMethod = ArpcMethod.METHOD_1
    ): IssuerAuthResult {
        // Validate inputs
        if (issuerAuthData.isEmpty()) {
            Timber.w("No issuer authentication data (Tag 91) provided")
            return IssuerAuthResult.NoAuthData
        }

        if (arqc.size != 8) {
            Timber.w("Invalid ARQC size: ${arqc.size} bytes (expected 8)")
            return IssuerAuthResult.Failed("Invalid ARQC size: ${arqc.size}")
        }

        if (sessionKey.size != 16) {
            Timber.w("Invalid session key size: ${sessionKey.size} bytes (expected 16)")
            return IssuerAuthResult.Failed("Invalid session key size: ${sessionKey.size}")
        }

        // Validate Tag 91 structure based on method
        return when (arpcMethod) {
            ArpcMethod.METHOD_1 -> {
                if (issuerAuthData.size < 8) {
                    return IssuerAuthResult.Failed("Tag 91 too short for Method 1: ${issuerAuthData.size} bytes (need 8)")
                }
                if (arc.size != 2) {
                    return IssuerAuthResult.Failed("Invalid ARC size: ${arc.size} bytes (expected 2)")
                }
                verifyArpcMethod1(arqc, issuerAuthData, arc, sessionKey)
            }
            ArpcMethod.METHOD_2 -> {
                if (issuerAuthData.size < 8) {
                    return IssuerAuthResult.Failed("Tag 91 too short for Method 2: ${issuerAuthData.size} bytes (need 8)")
                }
                verifyArpcMethod2(arqc, issuerAuthData, sessionKey)
            }
        }
    }

    /**
     * Verify ARPC using Method 1
     * ARPC = MAC(SK, ARQC XOR (ARC || 00 00 00 00 00 00))
     */
    private fun verifyArpcMethod1(
        arqc: ByteArray,
        issuerAuthData: ByteArray,
        arc: ByteArray,
        sessionKey: ByteArray
    ): IssuerAuthResult {
        // Tag 91 should contain at least 8 bytes (ARPC)
        if (issuerAuthData.size < 8) {
            return IssuerAuthResult.Failed("Tag 91 too short: ${issuerAuthData.size} bytes")
        }

        val arpc = issuerAuthData.copyOfRange(0, 8)

        val isValid = EmvSessionKeyDerivation.verifyArpcMethod1(
            arqc = arqc,
            arc = arc,
            arpc = arpc,
            sessionKey = sessionKey
        )

        return if (isValid) {
            Timber.d("Issuer authentication successful (Method 1)")
            IssuerAuthResult.Success(arpc, arc)
        } else {
            Timber.w("Issuer authentication failed - ARPC mismatch")
            IssuerAuthResult.Failed("ARPC verification failed")
        }
    }

    /**
     * Verify ARPC using Method 2
     * ARPC = 3DES(SK, ARQC)[0:4] XOR (CSU || Proprietary Data)
     */
    private fun verifyArpcMethod2(
        arqc: ByteArray,
        issuerAuthData: ByteArray,
        sessionKey: ByteArray
    ): IssuerAuthResult {
        // Method 2 Tag 91: ARPC (4) || CSU (4) || Optional Prop Data
        if (issuerAuthData.size < 8) {
            return IssuerAuthResult.Failed("Tag 91 too short for Method 2: ${issuerAuthData.size} bytes")
        }

        val arpc = issuerAuthData.copyOfRange(0, 4)
        val csu = issuerAuthData.copyOfRange(4, 8)
        val propData = if (issuerAuthData.size > 8) {
            issuerAuthData.copyOfRange(8, issuerAuthData.size)
        } else null

        val isValid = EmvSessionKeyDerivation.verifyArpcMethod2(
            arqc = arqc,
            csu = csu,
            proprietaryAuthData = propData,
            arpc = arpc,
            sessionKey = sessionKey
        )

        return if (isValid) {
            Timber.d("Issuer authentication successful (Method 2)")
            IssuerAuthResult.Success(arpc, csu)
        } else {
            Timber.w("Issuer authentication failed - ARPC Method 2 mismatch")
            IssuerAuthResult.Failed("ARPC Method 2 verification failed")
        }
    }

    /**
     * Validate script command whitelist
     * Only allow safe APDU commands in issuer scripts per EMV Book 3 Section 10.10
     *
     * @param command Raw APDU command from script
     * @return true if command is allowed
     */
    fun isCommandAllowed(command: ByteArray): Boolean {
        if (command.size < 4) return false

        val cla = command[0].toInt() and 0xFF
        val ins = command[1].toInt() and 0xFF

        // Check CLA - must be valid ISO 7816-4 format
        // Bits 7-6: 00/01/10 = valid (ISO or proprietary), 11 = invalid (reserved)
        // 0x00-0xBF = valid, 0xC0-0xFF = invalid
        val claValid = (cla and 0xC0) != 0xC0

        if (!claValid) {
            Timber.w("Blocked script command with invalid CLA: %02X", cla)
            return false
        }

        // Allowed commands per EMV Book 3 Section 10.10 and ISO 7816-9
        // Complete list of commands that may appear in issuer scripts
        val allowed = when (ins) {
            // Card/Application state management (ISO 7816-9)
            0x1E -> true  // APPLICATION BLOCK
            0x18 -> true  // APPLICATION UNBLOCK
            0x16 -> true  // CARD BLOCK

            // PIN management
            0x24 -> true  // PIN CHANGE/UNBLOCK (CHANGE REFERENCE DATA)
            0x2C -> true  // RESET RETRY COUNTER

            // Data update commands
            0xD6 -> true  // UPDATE BINARY
            0xDC -> true  // UPDATE RECORD
            0xDA -> true  // PUT DATA (single tag)
            0xDB -> true  // PUT DATA (multiple tags, odd INS)

            // Less common but valid script commands
            0xD2 -> true  // WRITE RECORD
            0x04 -> true  // DEACTIVATE FILE (ISO 7816-9, sometimes used)
            0x44 -> true  // ACTIVATE FILE (ISO 7816-9)

            else -> false
        }

        if (!allowed) {
            Timber.w("Blocked script command: CLA=%02X INS=%02X", cla, ins)
        }

        return allowed
    }

    /**
     * Parse issuer script template (Tag 71 or 72)
     * Extracts individual commands (Tag 86) from script
     *
     * Handles:
     * - Direct Tag 86 commands
     * - Nested TLV templates containing Tag 86
     * - Multiple Tag 86 in sequence
     *
     * @param scriptTemplate Raw Tag 71 or 72 data
     * @return List of parsed script commands
     */
    fun parseScriptTemplate(scriptTemplate: ByteArray): List<ScriptCommand> {
        val commands = mutableListOf<ScriptCommand>()
        parseScriptTemplateRecursive(scriptTemplate, 0, scriptTemplate.size, commands)
        Timber.d("Parsed ${commands.size} script commands, ${commands.count { it.isAllowed }} allowed")
        return commands
    }

    /**
     * Recursively parse TLV structure to find Tag 86 commands
     */
    private fun parseScriptTemplateRecursive(
        data: ByteArray,
        startOffset: Int,
        endOffset: Int,
        commands: MutableList<ScriptCommand>
    ) {
        var offset = startOffset

        while (offset < endOffset) {
            // Parse tag
            if (offset >= data.size) break
            var tag = data[offset].toInt() and 0xFF
            offset++

            // Check for multi-byte tag (bits 5-1 all set = 0x1F)
            if ((tag and 0x1F) == 0x1F) {
                if (offset >= data.size) break
                // Multi-byte tag - read subsequent bytes
                var nextByte = data[offset].toInt() and 0xFF
                tag = (tag shl 8) or nextByte
                offset++

                // Continue while bit 8 is set (more bytes follow)
                // Bounds check FIRST to prevent out-of-bounds access
                while (offset < data.size && (nextByte and 0x80) != 0) {
                    nextByte = data[offset].toInt() and 0xFF
                    tag = (tag shl 8) or nextByte
                    offset++
                }
            }

            if (offset >= data.size) break

            // Parse length
            var length = data[offset].toInt() and 0xFF
            offset++

            if (length == 0x81) {
                // Two-byte length form (1 byte follows)
                if (offset >= data.size) break
                length = data[offset].toInt() and 0xFF
                offset++
            } else if (length == 0x82) {
                // Three-byte length form (2 bytes follow)
                if (offset + 1 >= data.size) break
                length = ((data[offset].toInt() and 0xFF) shl 8) or
                        (data[offset + 1].toInt() and 0xFF)
                offset += 2
            } else if ((length and 0x80) != 0) {
                // Length encoding error - skip this byte and continue
                Timber.w("Invalid length encoding at offset ${offset - 1}")
                continue
            }

            if (offset + length > endOffset) {
                Timber.w("TLV length exceeds boundary: offset=$offset, length=$length, end=$endOffset")
                break
            }

            val valueStart = offset
            val valueEnd = offset + length

            when {
                // Tag 86 - Issuer Script Command
                tag == 0x86 -> {
                    val commandData = data.copyOfRange(valueStart, valueEnd)
                    val isAllowed = isCommandAllowed(commandData)
                    commands.add(ScriptCommand(
                        data = commandData,
                        isAllowed = isAllowed,
                        instruction = if (commandData.size >= 2) commandData[1] else 0
                    ))
                }

                // Constructed tag (bit 6 of first byte set) - recurse into it
                isConstructedTag(tag) -> {
                    parseScriptTemplateRecursive(data, valueStart, valueEnd, commands)
                }
            }

            offset = valueEnd
        }
    }

    /**
     * Check if a tag is constructed (contains nested TLVs)
     */
    private fun isConstructedTag(tag: Int): Boolean {
        // Bit 6 (0x20) of the first byte indicates constructed
        val firstByte = when {
            tag > 0xFFFF -> (tag shr 16) and 0xFF
            tag > 0xFF -> (tag shr 8) and 0xFF
            else -> tag
        }
        return (firstByte and 0x20) != 0
    }

    /**
     * ARPC verification method
     */
    enum class ArpcMethod {
        /** ARPC = MAC(ARQC XOR ARC) - Most common */
        METHOD_1,
        /** ARPC = 3DES(ARQC)[0:4] XOR CSU - Used by some issuers */
        METHOD_2
    }

    /**
     * Result of issuer authentication
     */
    sealed class IssuerAuthResult {
        /** Authentication successful */
        data class Success(
            val arpc: ByteArray,
            val responseCode: ByteArray
        ) : IssuerAuthResult() {
            override fun equals(other: Any?): Boolean {
                if (this === other) return true
                if (other !is Success) return false
                return arpc.contentEquals(other.arpc) &&
                        responseCode.contentEquals(other.responseCode)
            }

            override fun hashCode(): Int {
                var result = arpc.contentHashCode()
                result = 31 * result + responseCode.contentHashCode()
                return result
            }
        }

        /** No authentication data provided */
        object NoAuthData : IssuerAuthResult()

        /** Authentication failed */
        data class Failed(val reason: String) : IssuerAuthResult()
    }

    /**
     * Parsed script command with validation status
     */
    data class ScriptCommand(
        val data: ByteArray,
        val isAllowed: Boolean,
        val instruction: Byte
    ) {
        val instructionName: String
            get() = when (instruction.toInt() and 0xFF) {
                0x1E -> "APPLICATION BLOCK"
                0x18 -> "APPLICATION UNBLOCK"
                0x16 -> "CARD BLOCK"
                0x24 -> "PIN CHANGE/UNBLOCK"
                0x2C -> "RESET RETRY COUNTER"
                0xD6 -> "UPDATE BINARY"
                0xDC -> "UPDATE RECORD"
                0xDA -> "PUT DATA"
                0xDB -> "PUT DATA (ODD)"
                0xD2 -> "WRITE RECORD"
                0x04 -> "DEACTIVATE FILE"
                0x44 -> "ACTIVATE FILE"
                else -> "UNKNOWN (0x${"%02X".format(instruction)})"
            }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is ScriptCommand) return false
            return data.contentEquals(other.data) &&
                    isAllowed == other.isAllowed
        }

        override fun hashCode(): Int {
            var result = data.contentHashCode()
            result = 31 * result + isAllowed.hashCode()
            return result
        }
    }
}
