package com.atlas.softpos.crypto

import timber.log.Timber

/**
 * Issuer Script Authentication per EMV Book 2
 *
 * Validates issuer scripts (Tag 71/72) using issuer authentication data (Tag 91)
 * before allowing script execution. This prevents unauthorized script injection.
 *
 * Reference: EMV Book 2 v4.3, Section 8.2 - Issuer Authentication
 */
object IssuerScriptAuthenticator {

    /**
     * Authenticate issuer using Tag 91 data
     * EMV Book 2 Section 8.2.1
     *
     * Tag 91 format (10 bytes typically):
     * - ARPC (8 bytes): Authorization Response Cryptogram
     * - ARC (2 bytes): Authorization Response Code (optional, may be separate)
     *
     * @param arqc 8-byte ARQC generated by card
     * @param issuerAuthData Tag 91 data from online response
     * @param arc 2-byte Authorization Response Code (Tag 8A)
     * @param sessionKey Session key for MAC verification
     * @param arpcMethod ARPC verification method (1 or 2)
     * @return Authentication result with details
     */
    fun authenticateIssuer(
        arqc: ByteArray,
        issuerAuthData: ByteArray,
        arc: ByteArray,
        sessionKey: ByteArray,
        arpcMethod: ArpcMethod = ArpcMethod.METHOD_1
    ): IssuerAuthResult {
        if (issuerAuthData.isEmpty()) {
            Timber.w("No issuer authentication data (Tag 91) provided")
            return IssuerAuthResult.NoAuthData
        }

        return when (arpcMethod) {
            ArpcMethod.METHOD_1 -> verifyArpcMethod1(arqc, issuerAuthData, arc, sessionKey)
            ArpcMethod.METHOD_2 -> verifyArpcMethod2(arqc, issuerAuthData, sessionKey)
        }
    }

    /**
     * Verify ARPC using Method 1
     * ARPC = MAC(SK, ARQC XOR (ARC || 00 00 00 00 00 00))
     */
    private fun verifyArpcMethod1(
        arqc: ByteArray,
        issuerAuthData: ByteArray,
        arc: ByteArray,
        sessionKey: ByteArray
    ): IssuerAuthResult {
        // Tag 91 should contain at least 8 bytes (ARPC)
        if (issuerAuthData.size < 8) {
            return IssuerAuthResult.Failed("Tag 91 too short: ${issuerAuthData.size} bytes")
        }

        val arpc = issuerAuthData.copyOfRange(0, 8)

        val isValid = EmvSessionKeyDerivation.verifyArpcMethod1(
            arqc = arqc,
            arc = arc,
            arpc = arpc,
            sessionKey = sessionKey
        )

        return if (isValid) {
            Timber.d("Issuer authentication successful (Method 1)")
            IssuerAuthResult.Success(arpc, arc)
        } else {
            Timber.w("Issuer authentication failed - ARPC mismatch")
            IssuerAuthResult.Failed("ARPC verification failed")
        }
    }

    /**
     * Verify ARPC using Method 2
     * ARPC = 3DES(SK, ARQC)[0:4] XOR (CSU || Proprietary Data)
     */
    private fun verifyArpcMethod2(
        arqc: ByteArray,
        issuerAuthData: ByteArray,
        sessionKey: ByteArray
    ): IssuerAuthResult {
        // Method 2 Tag 91: ARPC (4) || CSU (4) || Optional Prop Data
        if (issuerAuthData.size < 8) {
            return IssuerAuthResult.Failed("Tag 91 too short for Method 2: ${issuerAuthData.size} bytes")
        }

        val arpc = issuerAuthData.copyOfRange(0, 4)
        val csu = issuerAuthData.copyOfRange(4, 8)
        val propData = if (issuerAuthData.size > 8) {
            issuerAuthData.copyOfRange(8, issuerAuthData.size)
        } else null

        val isValid = EmvSessionKeyDerivation.verifyArpcMethod2(
            arqc = arqc,
            csu = csu,
            proprietaryAuthData = propData,
            arpc = arpc,
            sessionKey = sessionKey
        )

        return if (isValid) {
            Timber.d("Issuer authentication successful (Method 2)")
            IssuerAuthResult.Success(arpc, csu)
        } else {
            Timber.w("Issuer authentication failed - ARPC Method 2 mismatch")
            IssuerAuthResult.Failed("ARPC Method 2 verification failed")
        }
    }

    /**
     * Validate script command whitelist
     * Only allow safe APDU commands in issuer scripts
     *
     * @param command Raw APDU command from script
     * @return true if command is allowed
     */
    fun isCommandAllowed(command: ByteArray): Boolean {
        if (command.size < 4) return false

        val cla = command[0].toInt() and 0xFF
        val ins = command[1].toInt() and 0xFF

        // Allowed commands per EMV Book 3 and ISO 7816-9
        val allowed = when (ins) {
            0x1E -> true  // APPLICATION BLOCK (ISO 7816-9)
            0x18 -> true  // APPLICATION UNBLOCK
            0x16 -> true  // CARD BLOCK
            0x24 -> true  // PIN CHANGE/UNBLOCK
            0xD6 -> true  // UPDATE BINARY
            0xDC -> true  // UPDATE RECORD
            0xDA -> true  // PUT DATA
            else -> false
        }

        if (!allowed) {
            Timber.w("Blocked script command: CLA=%02X INS=%02X", cla, ins)
        }

        return allowed
    }

    /**
     * Parse issuer script template (Tag 71 or 72)
     * Extracts individual commands (Tag 86) from script
     *
     * @param scriptTemplate Raw Tag 71 or 72 data
     * @return List of parsed script commands
     */
    fun parseScriptTemplate(scriptTemplate: ByteArray): List<ScriptCommand> {
        val commands = mutableListOf<ScriptCommand>()
        var offset = 0

        while (offset < scriptTemplate.size) {
            // Look for Tag 86 (Issuer Script Command)
            if (scriptTemplate[offset] != 0x86.toByte()) {
                offset++
                continue
            }
            offset++

            if (offset >= scriptTemplate.size) break

            // Parse length (handles 1 or 2 byte length)
            var length = scriptTemplate[offset].toInt() and 0xFF
            offset++

            if (length == 0x81) {
                // Two-byte length form
                if (offset >= scriptTemplate.size) break
                length = scriptTemplate[offset].toInt() and 0xFF
                offset++
            } else if (length == 0x82) {
                // Three-byte length form
                if (offset + 1 >= scriptTemplate.size) break
                length = ((scriptTemplate[offset].toInt() and 0xFF) shl 8) or
                        (scriptTemplate[offset + 1].toInt() and 0xFF)
                offset += 2
            }

            if (offset + length > scriptTemplate.size) break

            val commandData = scriptTemplate.copyOfRange(offset, offset + length)
            val isAllowed = isCommandAllowed(commandData)

            commands.add(ScriptCommand(
                data = commandData,
                isAllowed = isAllowed,
                instruction = if (commandData.size >= 2) commandData[1] else 0
            ))

            offset += length
        }

        Timber.d("Parsed ${commands.size} script commands, ${commands.count { it.isAllowed }} allowed")
        return commands
    }

    /**
     * ARPC verification method
     */
    enum class ArpcMethod {
        /** ARPC = MAC(ARQC XOR ARC) - Most common */
        METHOD_1,
        /** ARPC = 3DES(ARQC)[0:4] XOR CSU - Used by some issuers */
        METHOD_2
    }

    /**
     * Result of issuer authentication
     */
    sealed class IssuerAuthResult {
        /** Authentication successful */
        data class Success(
            val arpc: ByteArray,
            val responseCode: ByteArray
        ) : IssuerAuthResult() {
            override fun equals(other: Any?): Boolean {
                if (this === other) return true
                if (other !is Success) return false
                return arpc.contentEquals(other.arpc) &&
                        responseCode.contentEquals(other.responseCode)
            }

            override fun hashCode(): Int {
                var result = arpc.contentHashCode()
                result = 31 * result + responseCode.contentHashCode()
                return result
            }
        }

        /** No authentication data provided */
        object NoAuthData : IssuerAuthResult()

        /** Authentication failed */
        data class Failed(val reason: String) : IssuerAuthResult()
    }

    /**
     * Parsed script command with validation status
     */
    data class ScriptCommand(
        val data: ByteArray,
        val isAllowed: Boolean,
        val instruction: Byte
    ) {
        val instructionName: String
            get() = when (instruction.toInt() and 0xFF) {
                0x1E -> "APPLICATION BLOCK"
                0x18 -> "APPLICATION UNBLOCK"
                0x16 -> "CARD BLOCK"
                0x24 -> "PIN CHANGE/UNBLOCK"
                0xD6 -> "UPDATE BINARY"
                0xDC -> "UPDATE RECORD"
                0xDA -> "PUT DATA"
                else -> "UNKNOWN (0x${"%02X".format(instruction)})"
            }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is ScriptCommand) return false
            return data.contentEquals(other.data) &&
                    isAllowed == other.isAllowed
        }

        override fun hashCode(): Int {
            var result = data.contentHashCode()
            result = 31 * result + isAllowed.hashCode()
            return result
        }
    }
}
